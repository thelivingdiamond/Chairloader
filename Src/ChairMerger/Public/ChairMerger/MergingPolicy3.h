#pragma once
#include <boost/regex.hpp>
#include <ChairMerger/Export.h>

class MergingPolicy3;
class XmlErrorStack;
class XmlTypeLibrary;

//! MergingPolicy3 doesn't own its own children.
//! If you have recursive policies (that actually reference the type by name, not related to MergingPolicy3::IsRecursive()),
//! you'll get an ownership cycle. This prevents us from using std::shared_ptr or non-pointers.
//! Instead, all policies are owned either by FileMergingPolicy or by XmlTypeLibrary.
//! This interface allows MergingPolicy3 to allocate new policies when parsing XML files.
struct IMergingPolicyAllocator
{
    virtual ~IMergingPolicyAllocator() = default;
    virtual MergingPolicy3* AllocateEmptyPolicy() = 0;
};

//! @see IMergingPolicyAllocator.
class CHAIRMERGER_EXPORT MergingPolicyAllocator : public IMergingPolicyAllocator
{
public:
    MergingPolicyAllocator();
    MergingPolicyAllocator(MergingPolicyAllocator&&) noexcept = default;
    ~MergingPolicyAllocator();

    MergingPolicyAllocator& operator=(MergingPolicyAllocator&&) noexcept = default;

    // IMergingPolicyAllocator
    virtual MergingPolicy3* AllocateEmptyPolicy();

private:
    std::vector<std::unique_ptr<MergingPolicy3>> m_PolicyPool;
};

//! Defines the data model of a node type.
class CHAIRMERGER_EXPORT MergingPolicy3
{
public:
    static constexpr char XML_NODE_NAME[] = "Node";

    enum class ECollectionType
    {
        //! No child nodes are allowed.
        None,
        
        //! Key-value dictionary with arbitrary key.
        Dict,

        //! An ordered list of nodes with a separate integer index attribute.
        Array,

        //! Child nodes are allowed but the whole node must be replaced
        ReplaceOnly,
    };

    //! Defines a known/allowed attribute.
    struct Attribute
    {
        //! Name of the attribute.
        std::string name;

        //! Type of the attribute.
        std::string type;

        //! Whether the attribute must be present.
        bool required = false;

        //! Whether the attribute may be empty.
        bool allowEmpty = false;

        //! If true, mods won't be able to change the value of this attribute on existing nodes.
        bool readOnly = false;

        //! The attribute was generated by Chairloader's XML patches.
        bool generated = false;

        //! Comment describing the attribute.
        std::string comment;
    };

    //! Additional patches for the original file that must be applied for merging to work.
    struct Patches
    {
        //! Whether to add child index.
        bool addChildIndex = false;
        std::string childIndexAttr; //!< Index attribute name.
        int childIndexIncrement = 0; //!< Per-element increment.
        std::vector<std::string> removeAttr; //!< The list of attributes to be removed.

        //! Whether to add entity guid.
        bool addEntityGuid = false;
        std::string addEntityGuidName;
        std::string addEntityGuidFlagName;
        std::vector<std::string> addEntityGuidHash;

        //! Whether to copy serialize.xml to entity nodes.
        bool addEntitySerialize = false;
        std::string addEntitySerializeIdAttrName;
        std::string addEntitySerializeAttrName;
        std::string addEntitySerializeFilePath;

        //! Whether to replace all Entity IDs with Entity GUID finalizer expressions.
        bool replaceEntityIDs = false;
    };

    //! Defines the type of the collection and how child nodes should be merged.
    struct Collection
    {
        //! The type of the collection.
        ECollectionType type = ECollectionType::None;

        //! Use the child node name as part of the key.
        bool keyChildName = false;

        //! Allow duplicate keys. Should only be used when original Prey file contains an error.
        bool allowDuplicates = false;

        //! Use these child attributes as part of the key. They must be present in all children.
        std::vector<std::string> keyChildAttributes;

        //! Name of the index attribute.
        std::string arrayIndexAttr;

        //! Combines all keys into a comma-separated string.
        std::string GetKeyString() const;

        //! Combines all keys and values into a pair of comma-separated strings.
        std::pair<std::string, std::string> GetKeyValuePair(const pugi::xml_node& childNode) const;
    };

    //! Defines additional constraints on immediate children.
    struct ChildConstraints
    {
        //! The value of a child attribute must be unique among all of its sibling nodes.
        std::vector<std::string> uniqueAttributes;
    };

    using ChildNodeMap = std::map<std::string, const MergingPolicy3*, std::less<>>;
    using RegexChildNodeList = std::vector<std::pair<boost::regex, const MergingPolicy3*>>;

    MergingPolicy3() = default;
    MergingPolicy3(const MergingPolicy3&) = delete;
    MergingPolicy3(MergingPolicy3&&) noexcept = default;

    MergingPolicy3& operator=(const MergingPolicy3&) = default;
    MergingPolicy3& operator=(MergingPolicy3&&) noexcept = default;

    //! @returns Whether this policy applies to all unknown child nodes.
    bool IsRecursive() const { return m_IsRecursive; }
    void SetRecursive(bool state) { m_IsRecursive = state; }

    //! @returns The list of known/allowed attributes.
    const std::vector<Attribute>& GetAttributes() const { return m_Attributes; }
    std::vector<Attribute>& GetAttributes() { return m_Attributes; }

    //! @returns Whether unknown attributes are allowed. If false, causes an error if an attribute is not listed.
    bool IsAllowingUnknownAttributes() const { return m_AllowUnknownAttributes; }
    void SetAllowUnknownAttributes(bool state) { m_AllowUnknownAttributes = state; }

    //! @returns If specified, the node may have text contents of the specified type. If empty, text is not allowed.
    const std::string& GetTextType() const { return m_TextType; }
    void SetTextType(std::string_view textType) { m_TextType = textType; }

    //! @returns If text is allowed and false, if text is empty, causes a validation error.
    bool IsEmptyTextAllowed() const { return m_TextAllowEmpty; }
    void SetEmptyTextAllowed(bool state) { m_TextAllowEmpty = state; }

    //! @returns Patches.
    const Patches& GetPatches() const { return m_Patches; }
    Patches& GetPatches() { return m_Patches; }

    //! @returns The collection properties.
    const Collection& GetCollection() const { return m_Collection; }
    Collection& GetCollection() { return m_Collection; }

    //! @returns The child constraints.
    const ChildConstraints GetChildConstraints() const { return m_ChildConstraints; }
    ChildConstraints GetChildConstraints() { return m_ChildConstraints; }

    //! @returns The list of child nodes without regex.
    const ChildNodeMap& GetChildNodes() const { return m_ChildNodes; }

    //! @returns The list of child nodes that use regex.
    const RegexChildNodeList& GetChildNodesRegex() const { return m_ChildNodesRegex; }

    //! Finds an attribute in the policy.
    //! @returns Attribute or nullptr if not found.
    const Attribute* FindAttribute(std::string_view name) const;

    //! Finds the policy for a child node.
    //! @returns Policy or nullptr if not found.
    const MergingPolicy3* FindChildNode(std::string_view name) const;

    //! Adds a new node to the end. Node must be owned by something else.
    //! @{
    void AppendNode(std::string_view name, bool isRegex, const MergingPolicy3* node);
    //! @}

    //! Loads data from XML.
    void LoadXmlNode(IMergingPolicyAllocator* pAlloc, XmlTypeLibrary* pTypeLib, const pugi::xml_node& node, const XmlErrorStack& errorStack);

private:
    static constexpr char XML_NODE_ATTRIBUTES[] = "Attributes";
    static constexpr char XML_NODE_ATTRIBUTE[] = "Attribute";

    static constexpr char XML_NODE_PATCHES[] = "Patches";
    static constexpr char XML_NODE_REMOVE_ATTR[] = "RemoveAttribute";
    static constexpr char XML_NODE_ADD_CHILD_INDEX[] = "AddChildIndex";
    static constexpr char XML_NODE_ADD_ENTITY_GUID[] = "AddEntityGuid";
    static constexpr char XML_NODE_ADD_ENTITY_SERIALIZE[] = "AddEntitySerialize";
    static constexpr char XML_NODE_REPLACE_ENTITY_IDS[] = "ReplaceEntityIDs";

    static constexpr char XML_NODE_COLLECTION[] = "Collection";
    static constexpr char XML_NODE_PRIMARY_KEY[] = "PrimaryKey";
    static constexpr char XML_NODE_CHILD_INDEX_ATTR[] = "ChildIndexAttribute";
    static constexpr char XML_NODE_CHILD_NAME[] = "ChildName";
    static constexpr char XML_NODE_CHILD_ATTRIBUTE[] = "ChildAttribute";

    static constexpr char XML_NODE_CHILD_CONSTRAINTS[] = "ChildConstraints";
    static constexpr char XML_NODE_UNIQUE_ATTRIBUTE[] = "UniqueAttribute";

    static constexpr char XML_NODE_CHILD_NODES[] = "ChildNodes";
    static constexpr char XML_NODE_NODE_BY_TYPE[] = "NodeByType";

    bool m_IsRecursive = false;

    std::string m_TextType;
    bool m_TextAllowEmpty = false;

    std::vector<Attribute> m_Attributes;
    bool m_AllowUnknownAttributes = false;
    Patches m_Patches;
    Collection m_Collection;
    ChildConstraints m_ChildConstraints;

    ChildNodeMap m_ChildNodes;
    RegexChildNodeList m_ChildNodesRegex;

    void LoadXmlAttributes(const pugi::xml_node& node, const XmlErrorStack& parentErrorStack);
    void LoadXmlPatches(const pugi::xml_node& node, const XmlErrorStack& parentErrorStack);
    void LoadXmlCollection(const pugi::xml_node& node, const XmlErrorStack& parentErrorStack);
    void LoadXmlChildConstraints(const pugi::xml_node& node, const XmlErrorStack& parentErrorStack);
    void LoadXmlChildNodes(IMergingPolicyAllocator* pAlloc, XmlTypeLibrary* pTypeLib, const pugi::xml_node& node, const XmlErrorStack& parentErrorStack);
};

class CHAIRMERGER_EXPORT FileMergingPolicy3 : boost::noncopyable
{
public:
    enum class EMethod
    {
        //! This file can't be merged.
        ReadOnly,

        //! The file will be merged.
        Merge,

        //! The entire file will be replaced.
        Replace,

        //! Special merging for localization files.
        Localization,
    };

    static constexpr char XML_NODE_NAME[] = "MergingPolicy";

    FileMergingPolicy3() = default;
    FileMergingPolicy3(FileMergingPolicy3&& other) noexcept
    {
        *this = std::move(other);
    }

    FileMergingPolicy3& operator=(FileMergingPolicy3&& other) noexcept
    {
        // Why can't MSVC generate this on its own? Idk.
        if (&other != this)
        {
            m_FileName = std::move(other.m_FileName);
            m_FileNameRegex = std::move(other.m_FileNameRegex);
            m_IsFileNameRegex = std::move(other.m_IsFileNameRegex);
            m_IsRecursive = std::move(other.m_IsRecursive);
            m_Method = std::move(other.m_Method);
            m_Alloc = std::move(other.m_Alloc);
            m_RootNodeName = std::move(other.m_RootNodeName);
            m_RootNode = std::move(other.m_RootNode);
        }

        return *this;
    }

    //! Checks if the input file name matches this policy file.
    bool MatchFileName(const std::string& name) const;

    //! @returns Whether this policy matches files by regex.
    bool IsRegexName() const { return m_IsFileNameRegex; }

    //! @returns Whether this policy will apply to subfolders recursively.
    bool IsRecursive() const { return m_IsRecursive; }
    void SetRecursive(bool state) { m_IsRecursive = state; }

    //! @returns The file name. It might be a regex text.
    const std::string& GetFileName() const { return m_FileName; }
    void SetFileName(std::string_view fileName, bool isRegex);

    //! @returns The merging method for this file.
    EMethod GetMethod() const { return m_Method; }

    //! @returns The root node name.
    const std::string& GetRootNodeName() const { return m_RootNodeName; }

    //! @returns The root node.
    const MergingPolicy3& GetRootNode() const { return *m_RootNode; }

    //! Loads data from XML.
    void LoadXmlNode(XmlTypeLibrary* pTypeLib, const pugi::xml_node& node, const XmlErrorStack& parentErrorStack);

private:
    std::string m_FileName;
    boost::regex m_FileNameRegex;
    bool m_IsFileNameRegex = false;
    bool m_IsRecursive = false;
    EMethod m_Method = EMethod::ReadOnly;
    MergingPolicyAllocator m_Alloc;
    std::string m_RootNodeName;
    const MergingPolicy3* m_RootNode = nullptr;
};

using FileMergingPolicy3Ptr = std::unique_ptr<FileMergingPolicy3>;
