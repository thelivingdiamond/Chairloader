{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#chairloader","title":"Chairloader","text":""},{"location":"#by-thelivingdiamond-tmp64","title":"By thelivingdiamond &amp; tmp64","text":"<p>Chairloader is a modding framework built for Prey (2017) developed by Arkane. First and foremost chairloader is designed to enable modders to make mods for Prey on a scale never before seen. With realtime mod DLL loading modders are now given the ability to change not just the assets, but the code at the core of the game. There is a GUI built in with several functions to aid in modding (or messing around). Learn more below</p> <p>Licensed under GNU GPLv3</p>"},{"location":"#installation","title":"Installation","text":"<ul> <li>See Installation</li> <li>For steam deck and linux: Steam Deck and Linux</li> </ul>"},{"location":"#mod-manager","title":"Mod Manager","text":"<ul> <li>Easy installation of Chairloader</li> <li>Control load order and state of mods</li> <li>Automatic merging, packing, and deploying of XML files and assets</li> <li>Modders now only need to include the elements that are new/edited in the mod files</li> <li>Works for all XML assets in the game</li> </ul>"},{"location":"#chairloader-editor","title":"Chairloader Editor","text":"<ul> <li>Free cam</li> <li>Click on entities to inspect</li> <li>Entity editing</li> <li>Pause the game to explore with free cam</li> </ul>"},{"location":"#chairloader-tools","title":"Chairloader Tools","text":""},{"location":"#built-in-trainer-like-functions","title":"Built-in trainer-like functions:","text":"<ul> <li>Entity Manager</li> <li>Player Manager</li> <li>World Manager</li> <li>Full in-game console reimplemented</li> <li>Performance evaluation</li> <li>Full mod config manager</li> </ul>"},{"location":"#api-functionality","title":"API Functionality:","text":"<ul> <li>Automatic loading of mod DLLs (when enabled in mod loader)</li> <li>Full game header decompilation</li> <li>Example mod code</li> <li>Wiki documentation (coming soon)</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#installation","title":"Installation","text":""},{"location":"getting-started/steam-deck-and-linux/","title":"Steam Deck &amp; Linux Installation Guide","text":""},{"location":"getting-started/steam-deck-and-linux/#steam-deck-linux-installation-guide","title":"Steam Deck &amp; Linux Installation Guide","text":""},{"location":"getting-started/steam-deck-and-linux/#step-1-install-chairloader-mod-manager","title":"Step 1. Install Chairloader Mod Manager","text":"<ol> <li>(Steam Deck) Switch to Desktop Mode</li> <li>Download the latest release archive</li> <li>Extract the archive to <code>/home/deck/Applications/</code> </li> <li>Open Steam, Add a Game -&gt; Add Non-Steam Game -&gt; Browse... </li> <li>Browse to <code>ChairManager.exe</code></li> <li>Right-Click ChairManager -&gt; Properties -&gt; Compatibility -&gt; Force the use of a specific Steam Play compat tool</li> <li>Select Proton Experimental</li> <li>Close the window and launch ChairManager.exe</li> <li>Continue installation normally. Game may be located in:</li> <li>Internal storage: <code>/home/deck/.local/share/Steam/steamapps/common/Prey</code></li> <li>SD Card: <code>/run/media/deck/[long id]/steamapps/common/Prey</code></li> </ol>"},{"location":"getting-started/steam-deck-and-linux/#step-2-setting-up-the-game","title":"Step 2. Setting up the game","text":"<ol> <li>Select Prey in Steam Library</li> <li>Right-Click -&gt; Properties -&gt; General</li> <li>Type in the launch options:    <pre><code>WINEDLLOVERRIDES=\"mswsock.dll=n,b\" %command%\n</code></pre></li> <li>Close the window</li> <li>Launch Prey</li> </ol>"},{"location":"mod-manager/introduction/","title":"Chairloader Mod Manager","text":""},{"location":"mod-manager/introduction/#chairloader-mod-manager","title":"Chairloader Mod Manager","text":""},{"location":"mod-manager/introduction/#a-mod-manager-and-merger-for-prey-2017-mods","title":"A mod Manager and merger for Prey (2017) Mods","text":""},{"location":"mod-manager/introduction/#key-features","title":"Key Features","text":"<ul> <li>Install mods from .zip or .7z file</li> <li>Install legacy mods from .pak</li> <li>Enable and disable mods from loading through Chairloader</li> <li>Easy Chairloader install and uninstall wizards</li> <li>Automatic DLL patching to add Chairloader support</li> <li>Asset management and patching</li> <li>Merging XML based asset files<ul> <li>Base asset files and level files are supported</li> <li>Localization file support coming soon!</li> </ul> </li> <li>Supports merging \"Legacy\" mods</li> </ul>"},{"location":"mod-manager/introduction/#easy-install-wizard-for-chairloader","title":"Easy Install Wizard for Chairloader","text":""},{"location":"mod-manager/introduction/#intuitive-mod-management-interface","title":"Intuitive Mod Management Interface","text":""},{"location":"mod-manager/introduction/#legacy-mod-support","title":"Legacy Mod Support","text":""},{"location":"mod-manager/introduction/#mod-merging-and-deployment","title":"Mod Merging and Deployment","text":""},{"location":"mod-manager/introduction/#game-dll-patching-to-enable-chairloader-support-on-steamgog","title":"Game DLL Patching to enable Chairloader Support on Steam/GOG","text":""},{"location":"modding/config-files/","title":"Config Files","text":""},{"location":"modding/config-files/#config-files","title":"Config Files","text":"<p>This is about how to setup and handle mod configuration files.</p>"},{"location":"modding/config-files/#config-files-and-default-config-files","title":"Config Files and Default Config Files","text":"<p>Config files are very important for more advanced modding. When your mod is loaded into ChairManager, it attempts to locate a default mod config. This process looks for a file in your root mod directory with the corresponding name. This name should be: <code>YourModName_default.xml</code>. If this file is present, it will be copied to the config directory. If it is not, then a default blank file will be created in the config directory.</p> <p>The root XML node should be named the same as your mod name. Each child node will be a config value, and each node must have a type attribute set, as is explained below. An example configuration file would be as follows: </p><pre><code>&lt;TheChair.ExampleMod version=\"1.0.0\"&gt;\n    &lt;testString type=\"string\" display_name=\"Test String\"&gt;The quick brown fox jumped over the lazy dog&lt;/testString&gt;\n    &lt;testBool type=\"bool\" description=\"This is a test boolean\"&gt;true&lt;/testBool&gt;\n    &lt;testInt type=\"int\" display_name=\"XXX Value\"&gt;-200&lt;/testInt&gt;\n    &lt;testUInt type=\"uint\" display_name=\"YYY percent\" description=\"Important number for stuff\"&gt;4294967295&lt;/testUInt&gt;\n    &lt;testInt64 type=\"int64\"&gt;-12369420000000000&lt;/testInt64&gt;\n    &lt;testUInt64 type=\"uint64\"&gt;18446744073709551615&lt;/testUInt64&gt;\n    &lt;testFloat type=\"float\"&gt;68.7199936&lt;/testFloat&gt;\n    &lt;testXMLNode type=\"xmlnode\"&gt;\n        &lt;node1 type=\"string\" display_name=\"Child Node 1\"&gt;I am a child node&lt;/node1&gt;\n        &lt;node2 type=\"string\" display_name=\"Child Node 2\"&gt;Important Config Details&lt;/node2&gt;\n    &lt;/testXMLNode&gt;\n    &lt;testEnum type=\"enum\" display_name=\"Test Enum Value\" description=\"Hello this is a description\"&gt;\n        &lt;selected&gt;B&lt;/selected&gt;\n        &lt;option name=\"Option A\" description=\"Description of this option\"&gt;A&lt;/option&gt;\n        &lt;option name=\"Option B\" description=\"Description of this option\"&gt;B&lt;/option&gt;\n        &lt;option name=\"Option C\" description=\"Description of this option\"&gt;C&lt;/option&gt;\n    &lt;/testEnum&gt;\n&lt;/TheChair.ExampleMod&gt;\n</code></pre><p></p> <p>Each node must have a <code>type</code> attribute. In addition, each node may have additional special attributes: - <code>display_name</code>: a human readable name - <code>description</code>: a description of the node which is shown when hovering over the value in ChairManager</p> <p>It is important that every XML node be named in a way that is a valid variable name in Lua. This means it must consist of letters, underscores, and digits. It may not start with a digit. The names are case sensitive.</p>"},{"location":"modding/config-files/#value-types","title":"Value Types","text":"<p>Config values in chairloader are typed. This helps with both providing the correct editing environment for users and more advanced configuration features internally. The types available are: - <code>bool</code> - <code>int</code> - <code>unsigned int</code> - <code>enum</code> - <code>int64</code> - <code>unsigned int64</code> - <code>float</code> - <code>string</code> - <code>xmlnode</code></p>"},{"location":"modding/config-files/#boolean-bool","title":"Boolean (Bool)","text":"<ul> <li>True/False Value</li> </ul>"},{"location":"modding/config-files/#string","title":"string","text":"<ul> <li>This is a string of characters, i.e. words and text.</li> </ul>"},{"location":"modding/config-files/#enum","title":"enum","text":"<ul> <li>This is an enumerated value, meaning that it can only be one of several specified values. Currently these can only be string values</li> <li>Each value is an <code>&lt;option&gt;</code> xml node, and the currently selected is stored in <code>&lt;selected&gt;</code>.</li> <li>Each value node may have a <code>name</code> attribute in addition to a description attribute</li> </ul>"},{"location":"modding/config-files/#int","title":"int","text":"<ul> <li>32 bit signed integer (can be negative or positive)</li> </ul>"},{"location":"modding/config-files/#unsigned-int","title":"unsigned int","text":"<ul> <li>32 bit unsigned integer (can only be positive)</li> </ul>"},{"location":"modding/config-files/#int64","title":"int64","text":"<ul> <li>64 bit signed integer (can be negative or positive)</li> </ul>"},{"location":"modding/config-files/#unsigned-int64","title":"unsigned int64","text":"<ul> <li>64 bit unsigned integer (can only be positive)</li> </ul>"},{"location":"modding/config-files/#float","title":"float","text":"<ul> <li>Floating point decimal number (i.e. <code>1.5</code>, <code>20.62</code>, etc...)</li> </ul>"},{"location":"modding/config-files/#xmlnode","title":"xmlnode","text":"<ul> <li>This type indicates that it contains more XML rather than a text value</li> <li>These can serve as either folders for other config values or as a way to store a custom format of data in the config file.</li> </ul>"},{"location":"modding/config-files/#lua-wildcard-attributes","title":"Lua Wildcard Attributes","text":"<p>When creating xml files, it is often useful to have xml attributes that are configurable. To accomplish this Chairloader implements what are called 'Attribute Wildcards'. There are several important specifications to keep in mind when using them: 1. In order to indicate that attributes should be used the attribute string must be in the following form: <code>xmlAttribute=\"{{ ExpressionHere }}\"</code>     - The use of double brackets is critical, as these are the tokens used to find and resolve these in the merging process 2. The expression string implements Lua, and can access config variables from your own mod and others. More details on the Lua and variable access specifications can be found below. 3. While uint64 and int64 are usable in C++, due to Lua limitations they are passed as strings, so they're not usable for calculations easily.</p>"},{"location":"modding/config-files/#lua-syntax-and-expressions","title":"Lua Syntax and Expressions","text":"<p>The Lua runs in a sandboxed environment that prohibits writing to global variables. This means that config values are constant values that cannot be changed during the merging process. When evaluating an expression, it is expected it will return a value, which is then passed back to the program and into the XML file. If there is no return statement present, then the evaluated Lua expression is: <code>return ( yourExpressionHere )</code>. If you would like to perform more complicated operations, you may instead include your own return statement in your expression.</p> <p>Some of the advantages of this approach is the ability to use operations in your expressions. This means you can use things like boolean operators to combine expressions, comparison operators to test conditions, and more. Math, string concatenation, all of that is possible with just a little bit of Lua knowledge.</p>"},{"location":"modding/config-files/#variable-access","title":"Variable Access","text":"<p>In Attribute Wildcards all variables are stored according to a combination of the mod path and the xml path inside the config file. If the config variable comes from your mod, you only have to put the xml path, which is often just the name of the config node, i.e. just the global variable <code>valueName</code>. Nested nodes are accessible as <code>XmlNode1.Value</code>. If you are referring to an external mod, the variables are available as <code>G.ModName.value</code>.</p>"},{"location":"modding/config-files/#enums","title":"Enums","text":"<p>When accessing an enum by name, it returns the currently selected value. There is a second variable added with <code>_enum</code> appended to it. This is a table that stores the enumerated options. They are stored as <code>option0, option1, option2, ...</code> for as many options as are available.</p>"},{"location":"modding/config-files/#special-functions","title":"Special Functions","text":"<p>There are several functions available to the Lua environment that are specified by Chair Manager. They are: - <code>IsModEnabled(string modName)</code>     - This returns a boolean value indicating if the specified mod is enabled or not. - <code>Random(int lowerBound, int upperBound)</code>     - This returns a random integer from the lowerBound up to and including the upper bound. - <code>RandomFloat(float lowerBound, float upperBound)</code>     - This returns a random float from the lowerBound up to and including the upper bound. </p>"},{"location":"modding/file-structure/","title":"File structure","text":""},{"location":"modding/file-structure/#proper-file-structure-for-prey-directory","title":"Proper file structure for Prey directory","text":"<p>This is how the Prey directory should look once you have installed Chairloader. The <code>Mods</code> folder is created automatically when installed.</p> <p></p>"},{"location":"modding/file-structure/#proper-file-structure-for-mods-folder","title":"Proper file structure for Mods folder","text":"<p>The Mods folder should have two folders inside of it upon first creation, <code>config</code> and <code>Legacy</code>. Any Chairloader mods should go here, and they are automatically placed here by the install mod from file function.</p> <p></p>"},{"location":"modding/file-structure/#config","title":"Config","text":"<p>The <code>config</code> folder contains all configuration files for mods, including the primary config file for the Chairloader system, <code>Chairloader.xml</code>. If Chairloader.xml is not present Chairloader will not work.</p> <p></p>"},{"location":"modding/file-structure/#legacy","title":"Legacy","text":"<p>This is where mods that were released before Chairloader will go. They are typically packaged as a .pak file and were intended to go in the <code>Precache/</code> folder in the prey directory. They do not have a ModInfo.xml file, and as such are missing some of the features available in Chairloader. However, placing them here will enable Chairloader compatibility merging with other mods.</p> <p></p>"},{"location":"modding/file-structure/#proper-file-structure-for-a-chairloader-mod","title":"Proper file structure for a Chairloader mod","text":"<p>A chairloader mod is differentiated by having a <code>ModInfo.xml</code> and has the ability to contain a DLL file that will be loaded. The current example <code>ModInfo.xml</code> can be found in the Examples folder in the latest release. A default config file should also be provided. The appropriate file structure is as follows:</p> <p></p> <p>Inside the <code>Data</code> folder is where the asset file structure goes:</p> <p></p>"},{"location":"modding/file-structure/#proper-file-structure-for-a-legacy-mod","title":"Proper file structure for a Legacy mod","text":"<p>A legacy mod can only contain XML and asset elements, and as such the file structure is simpler:</p> <p></p>"},{"location":"modding/file-structure/#a-note-on-asset-merging-and-file-paths","title":"A note on asset merging and file paths","text":"<p>For the asset data of a mod, the file names and path names are not case sensitive. However, the relative paths must be correct. Please ensure that the assets are in the proper paths when creating or editing a mod. </p>"},{"location":"modding/introduction/","title":"Introduction","text":""},{"location":"modding/introduction/#introduction","title":"Introduction","text":"<p>This series of articles will give you the information necessary to make basic mods for Prey (2017) using Chairloader Mod Loader.</p> <p>If you have any questions, feel free to ask them over at the Prey Discord Server in <code>#prey-modding</code>.</p>"},{"location":"modding/introduction/#modding-basics","title":"Modding basics","text":"<p>Prey is built using the CRYENGINE game engine. The \"hard\" game logic is written in C++ and is compiled into the PreyDll.dll binary file. But the most of the actual game settings are stored in various XML files in the game assets.</p>"},{"location":"modding/introduction/#assets","title":"Assets","text":"<p>Game assets are stored in <code>*.pak</code> files in the game folder. When running the game, all files from PAKs are combined into a single virtual file system. If a file with the same name exists in multiple PAKs, then PAKs loaded at a later point override files from earlier PAKs.</p> <p>The game supports two types of PAK files. 1. Regular ZIP archives. You can read and write them using any archive tool (e.g. 7-Zip).    - GOG and EGS versions use this format. 2. Encrypted PAKs. They can only be read by the game or special extraction tools.    - Steam uses this format.</p>"},{"location":"modding/introduction/#asset-patching","title":"Asset Patching","text":"<p>The game loads PAKs from <code>GameSDK\\Precache</code> last. This lets you install custom PAKs in this folder with the name like <code>patch_[any name you want].zip</code> (e.g. <code>patch_chairloader.pak</code>). This is how most existing mods are installed into Prey.</p> <p>Note: <code>GameSDK\\Precache</code> folder doesn't exist in EGS version but it's still supported if you make it manually.</p>"},{"location":"modding/introduction/#asset-merging","title":"Asset Merging","text":"<p>As part of the modding process, you will need to edit XML files of huge sizes (sometimes thousands of lines long). If do this directly, not only will you go insane, but your mod will be incompatible with every other mod that modifies the same file.</p> <p>Chairloader solves this problem. As a mod author, you only need to specify the changes to the game files. Chairloader will take all changes from all installed mods and will merge them into a single file.</p>"},{"location":"modding/introduction/#making-your-first-mod","title":"Making your first mod","text":""},{"location":"modding/introduction/#prerequisites","title":"Prerequisites","text":""},{"location":"modding/introduction/#required","title":"Required","text":"<p>To follow this guide, you must install Chairloader and make sure it works. 1. Install Chairloader 2. Open folder: <code>ChairManager/PreyFiles</code>. You should see <code>FilesExtracted.dat</code> and a set of folders. </p>"},{"location":"modding/introduction/#optional","title":"Optional","text":"<p>Additionally, you can install a few tools to make modding easier. 1. Visual Studio Code 2. XML Extension for VS Code 3. indent-rainbow for VS Code</p>"},{"location":"modding/introduction/#option-a-using-preditor","title":"Option A. Using Preditor","text":"<p>This is the recommended option.</p> <p>Preditor is a mod editor for Prey. Each Preditor project runs in a separate environment. It lets you test mods independent from each other and without risk of damaging your save files.</p> <p>Note: At the moment, Preditor doesn't support level file merging. Use Chairloader for level mods for the time being.</p> <ol> <li>Enable Developer Mode in Windows. This is required because Preditor uses symbolic links to reduce disk space usage when merging non-XML files.</li> <li>If you can't enable Developer Mode or don't use Windows 10, you MUST run Preditor.exe as Administrator.</li> <li>Open ChairManager folder.</li> <li>Launch <code>Preditor.exe</code>. You should see the Project Select dialog. </li> <li>Press <code>New Project</code>.</li> <li>Fill in the fields.</li> <li>Mod Name. This is the internal name of the mod. It should look like <code>authorName.mySuperMod</code>.</li> <li>Display Name. This is the name that the use will see. Example: <code>My Super Mod</code></li> <li>Author. This is your name. Example: <code>Myself</code></li> <li>Has a DLL. If you're making a DLL mod, tick this checkbox and type the DLL name.</li> <li>Project Location. Where to place your mod.</li> <li>Create Project Folder. If ticked, a new folder with the mod name will be created.</li> </ol> <p> 6. Press <code>Create</code> 7. Select your mod in the project list. This will open Preditor with just your mod loaded. 8. Adjust windows for your liking.  </p> Recommended Layout <p> </p>"},{"location":"modding/introduction/#option-b-manually","title":"Option B. Manually","text":"<ol> <li>Choose an internal name for your mod. It should look like <code>authorName.mySuperMod</code>.</li> <li>Open Prey installation folder and then open <code>Mods</code> folder.</li> <li>Create a folder with your mod's internal name (e.g. <code>authorName.mySuperMod</code>) in <code>Mods</code>.</li> <li>Copy <code>Examples/AuthorName.ModExample/ModInfo.xml</code> from ChairManager to the created folder.</li> <li>Open <code>ModInfo.xml</code> in a text editor (e.g. VS Code).</li> <li>Adjust attributes to match your mod. See the descriptions above (in Option A. Using Preditor).</li> <li>Open ChairManager</li> <li>Install and Enable your mod.</li> <li>Press <code>Save mod list</code> and <code>Merge mods</code>.</li> </ol>"},{"location":"modding/introduction/#whats-next","title":"What's next","text":"<p>Now that you have a mod, you can start modifying files. Follow the Basic XML Mod guide to get an idea on how XML mods work.</p>"},{"location":"modding/cpp/building-chairloader/","title":"Building Chairloader","text":""},{"location":"modding/cpp/building-chairloader/#building-chairloader","title":"Building Chairloader","text":"<p>Before you can start making C++ mods, you have to build Chairloader from source code on your computer. This ensures that you have a development environment ready and can, if necessary, step into Chairloader code when debugging.</p>"},{"location":"modding/cpp/building-chairloader/#prerequisites","title":"Prerequisites","text":"<p>You must install the following software:</p> <ol> <li>Visual Studio 2022 or newer (do not confuse with Visual Studio Code)</li> <li>Community version will suffice</li> <li>When installing, select:<ul> <li>Workloads:</li> <li>Desktop development with C++</li> <li>Individual components:</li> <li>C++ MFC for latest build tools (x86 &amp; x64)</li> <li>C++ ATL for latest build tools (x86 &amp; x64)</li> </ul> </li> <li>Git for Windows</li> <li>CMake (Latest Release, Windows x64 Installer)</li> <li>vcpkg</li> <li>Follow only Step 1 - Set up vcpkg.      You don't need to do the rest</li> </ol>"},{"location":"modding/cpp/building-chairloader/#step-1-cloning-chairloader-repo","title":"Step 1. Cloning Chairloader repo","text":"<ol> <li>Create a folder somewhere for Chairloader</li> <li>Right-Click and select \"Git Bash Here\" </li> <li>Copy &amp; Paste this command in the opened console window</li> <li>DO NOT use Ctrl+V. It doesn't paste text. Right-Click instead and select \"Paste\".    <pre><code>git clone https://github.com/thelivingdiamond/Chairloader.git\n</code></pre> </li> </ol>"},{"location":"modding/cpp/building-chairloader/#step-2-generating-vs-solution-using-cmake","title":"Step 2. Generating VS solution using CMake","text":"<ol> <li>Open the <code>Chairloader</code> folder with the source code.</li> <li>Create a folder named <code>_build</code></li> <li>Open CMake GUI</li> <li>Set \"Where is the source code\" to the folder with Chairloader source code</li> <li>Set \"Where to build the binaries\" to the created <code>_build</code> folder </li> <li>Press \"Configure\" at the bottom. Configuration dialog will open.</li> <li>Select:</li> <li>Specify the generator for this project: your Visual Studio version</li> <li>Optional platform for generator: x64</li> <li>\"Specify toolchain file for cross-compiling\"</li> </ol> <p> 8. Click Next. 9. Specify the Toolchain file: <code>path_to_vcpkg/scripts/buildsystems/vcpkg.cmake</code>  10. Press Finish. 11. Wait for all dependencies to download and build. This may take up to 10 minutes but it will only happen once. 12. You should see something like this:  13. Set <code>PREY_DLL_DIR</code> to where <code>PreyDll.dll</code> is.     Example: <code>F:/Games/SteamLibrary/steamapps/common/Prey/Binaries/Danielle/x64/Release</code> 14. Press \"Configure\" and \"Generate\"</p>"},{"location":"modding/cpp/building-chairloader/#step-3-building-chairloader","title":"Step 3. Building Chairloader","text":"<ol> <li>In CMake, press \"Open Project\"</li> <li>Or open <code>Chairloader.sln</code> file manually. It will be located in <code>_build</code> folder</li> <li>Visual Studio will open. Press \"Build\" -&gt; \"Build Solution\". </li> <li>Wait for everything to build</li> <li>Output window should contain this:    <pre><code>========== Build: 30 succeeded, 0 failed, 0 up-to-date, 2 skipped ==========\n========== Build completed at 10:10 and took 01:38,606 minutes ==========\n</code></pre></li> <li>In Solution Explorer, navigate to \"Chairloader (Game)\" -&gt; \"Chairloader.Dll\"</li> <li>Right-Click and select \"Set as Startup Project\" </li> <li>Press \"Debug\" -&gt; \"Start Debugging\" </li> <li>The game with Chairloader in Developer Mode will start</li> </ol>"},{"location":"modding/cpp/building-chairloader/#alternative-ides-and-compilers","title":"Alternative IDEs and Compilers","text":"<p>Note: This is an advanced section for experienced C++ developers</p> <p>Alternatively, you can use CLion, Rider or VS Code. But you must use the Visual Studio Build Tools compiler. There is no guide on how to set everything up. You're on you own.</p> <p>Chairloader can be built using <code>clang-cl</code> compiler in MSVC compatibility mode. But that mode still requires you to install Visual Studio Build Tools.</p> <p>MSYS2 compilers are not supported.</p>"},{"location":"modding/cpp/engine-source-code/","title":"Engine Source Code","text":""},{"location":"modding/cpp/engine-source-code/#engine-source-code","title":"Engine Source Code","text":"<p>Prey (2017) is based on CRYENGINE version 3/4. CRYENGINE 5 and newer has public source code.</p> <p>CRYENGINE versions 5.0-5.6 used to be available in a public repo on CRYTEK's GitHub. The repo has been removed soon after the release of CRYENGINE 5.7 LTS, and required SDKs went along with it.</p>"},{"location":"modding/cpp/engine-source-code/#cryengine-52","title":"CRYENGINE 5.2","text":"<p>This is the closest public version to the one used in Prey. For Chairloader development, it can be found in a mirror.</p> <p>Notable differences from Prey's engine are: - File structure in <code>CryCommon</code> split by engine modules. CRYENGINE 3 and Prey have all files in one directory. - Different (how?) entity archetype code.</p>"},{"location":"modding/cpp/engine-source-code/#cryengine-57","title":"CRYENGINE 5.7","text":"<p>This version is hosted in a private repository. To get access to it, you need to fill out a form. Check here for details.</p>"},{"location":"modding/cpp/mod-project-setup/","title":"Mod Project Setup","text":""},{"location":"modding/cpp/mod-project-setup/#mod-project-setup","title":"Mod Project Setup","text":"<p>This article will show you how to setup a C++ mod project.</p>"},{"location":"modding/cpp/mod-project-setup/#prerequisites","title":"Prerequisites","text":"<ol> <li>Build Chairloader</li> <li>Create an empty mod</li> </ol>"},{"location":"modding/cpp/mod-project-setup/#step-1-creating-basic-files","title":"Step 1. Creating basic files","text":"<ol> <li>Open your mod folder.</li> <li>Copy the contents of <code>Chairloader/ExampleMod</code> to your mod folder</li> <li>Follow the guide in <code>Chairloader/ExampleMod/README.md</code> to set the name of the mod</li> <li>Open <code>ModInfo.xml</code> and set <code>dllName</code> to <code>YourMod.dll</code></li> </ol>"},{"location":"modding/cpp/mod-project-setup/#step-2-generating-vs-solution-using-cmake","title":"Step 2. Generating VS solution using CMake","text":"<ol> <li>Create folder named <code>_build</code> in your mod folder</li> <li>Open CMake GUI</li> <li>Configure CMake similarly to Building Chairloader until you get an error</li> <li>Set <code>CHAIRLOADER_COMMON_PATH</code> to <code>[path to Chairloader source code]/Common</code> and press \"Configure\"</li> <li>Set <code>MOD_DLL_PATH</code> to the same folder as your mod. This will place the DLL file in there automatically.</li> <li>Press \"Configure\", \"Generate\", \"Open Project\"</li> </ol>"},{"location":"modding/cpp/mod-project-setup/#step-3-configuring-debugging-settings","title":"Step 3. Configuring debugging settings","text":"<p>This is still WIP. Here's the basics.</p> <ol> <li>Open the project in Visual Studio</li> <li>Open mod project's properties</li> <li>\"Configuration Properties\" -&gt; \"Debugging\"</li> <li>When using Preditor, set:<ul> <li>\"Command\": path to Preditor.exe</li> <li>\"Command Arguments\": <code>-- -noaudio</code> (this will speed up loading considerably)</li> <li>\"Working directory\": folder with Preditor.exe</li> </ul> </li> <li>When using normal game, set:<ul> <li>\"Command\": path to Prey.exe</li> <li>\"Command Arguments\": <code>-noaudio</code> (this will speed up loading considerably)</li> <li>\"Working directory\": folder with Prey.exe</li> </ul> </li> <li>Set the mod project as Startup Project</li> <li>Debug -&gt; Launch</li> </ol>"},{"location":"modding/lua/introduction/","title":"Lua Modding Introduction","text":""},{"location":"modding/lua/introduction/#lua-modding-introduction","title":"Lua Modding Introduction","text":"<p>CRYENGINE includes a Lua 5.1.1-rc4 interpreter (from 2006) for entity scripting.</p> <p>Relevant resources:</p> <ul> <li>Lua Scripting - CRYENGINE Technical Documentation</li> <li>Script Entity - CRYENGINE Technical Documentation</li> <li>Creating a New Entity Class - CRYENGINE Technical Documentation</li> <li>Entity script examples - bare-minimum-cryengine3</li> </ul>"},{"location":"modding/lua/introduction/#executing-scripts","title":"Executing Scripts","text":"<p>Lua scripts can be executed in the console by prefixing them with a <code>#</code> symbol. </p><pre><code>#ChairError(\"Hello from Lua\")\n[Lua] [Error] Hello from Lua\n</code></pre> You can execute files using <pre><code>-- Syntax: LoadScript(path, bReload = false, bRaiseError = true)\n-- Without bReload = true, the script will only be loaded once.\n#Script.LoadScript(\"D:/Path/To/Script.lua\", true)\n</code></pre><p></p>"},{"location":"modding/lua/introduction/#formatting-rules","title":"Formatting Rules","text":"<p>Just like C++, Lua doesn't have an official formatting rule set. CRYENGINE seems to extend their C++ rules to Lua - Indent using tabs - Functions use <code>PascalCase</code> - Variables use <code>camelCase</code>, sometimes with Hungarian notation <code>bBoolVar</code>, <code>flFloatVar</code> - Global variables are prefixed with <code>g_</code>: <code>g_Pi, g_HitTable, ...</code></p>"},{"location":"modding/lua/introduction/#entity-scripts","title":"Entity Scripts","text":"<p>Primary use of Lua in CRYENGINE is to define new entity classes, their properties (the ones you see in EntityArchetypes XML) and some of the logic via callbacks.</p> <p>See Relevant resources section for more details.</p>"},{"location":"modding/lua/introduction/#lua-mods","title":"Lua Mods","text":"<p>Chairloader mods can include custom Lua scripts. The mod must have a script in <code>Data/Scripts/Mods/mod.name/main.lua</code> in specific format.</p> <p>The script is run in the global environment. Make sure you always use <code>local</code> for variables and functions. Otherwise the may be overwriten by other mods.</p> <p>Check the example for details.</p>"},{"location":"modding/lua/introduction/#logging","title":"Logging","text":"<p>Chairloader provides a few formatted and unformatted logging functions. </p><pre><code>-- Formatted logging (using string.format)\nChairLog(\"Hello no. %d\", 1)   -- Normal message, like CryLog in C++\nChairWarn(\"Hello no. %d\", 2)  -- [Warning] prefix, like CryWarning in C++\nChairError(\"Hello no. %d\", 3) -- [Error] prefix, like CryError in C++\n\n-- Unformatted logging (functions take a string)\nChairloader.Log(\"Hello no. \" .. tostring(1))\nChairloader.LogWarning(\"Hello no. \" .. tostring(2))\nChairloader.LogError(\"Hello no. \" .. tostring(3))\n</code></pre><p></p>"},{"location":"modding/lua/introduction/#entity-table-hooks","title":"Entity Table Hooks","text":"<p>Chairloader provides a mechanism to hook functions in entity script tables.</p> <p>Use <code>Chairloader.HookEntityCallback</code> in <code>HookEntities</code>. Syntax: </p><pre><code>-- Registers a hook function for an entity callback.\n-- @param entityClassName   Entity class name.\n-- @param callbackName      Callback name.\n-- @param handler       Hook handler.\nChairloader.HookEntityCallback = function(entityClassName, callbackName, handler)\n</code></pre> Hook handler is a function that takes the following arguments: - Next handler. - Entity instance (<code>self</code>). - Callback arguments.<p></p> <p>Example usage: </p><pre><code>local function ArkTurret_OnLoad(nextHandler, self, saved)\n    -- Call the original function (similar to InvokeOrig() in C++)\n    nextHandler(self, saved)\n\n    self.testScale = saved.testScale\n    if self.testScale == nil then\n        self.testScale = 1\n    end\n\n    ChairWarn(\"ArkTurret_OnLoad %.3f\", self.testScale)\n    Entity.SetSlotScale(self, 0, self.testScale)\nend\n\nfunction gMod:HookEntities()\n    Chairloader.HookEntityCallback(\"ArkTurret\", \"OnLoad\", ArkTurret_OnLoad)\nend\n</code></pre><p></p> <p>If you don't know the exact arguments of a callback, you can use variadic args. </p><pre><code>local function MyCallback(nextHandler, self, ...)\n    nextHandler(self, ...)\n    ChairLog(\"Do something here...\")\nend\n</code></pre><p></p>"},{"location":"modding/lua/introduction/#lua-mod-interop","title":"Lua Mod Interop","text":"<p>Lua mods can have <code>PublicExport</code> entry in their main table. If they have one, other mods can get a reference to it using the following functions. </p><pre><code>-- Gets the export table for a given mod.\n-- If mod is not found, returns nil.\nChairloader.GetModExportTable = function (modName)\n\n-- Gets the export table for a given mod.\n-- If mod is not found, throws an error.\nChairloader.RequireModExportTable = function (modName)\n</code></pre><p></p> <p>Those functions can only be called after all mods have been registered (e.g. in <code>gMod:OnInit</code>).</p>"},{"location":"modding/lua/introduction/#bridging-lua-and-c","title":"Bridging Lua and C++","text":"<p>CRYENGINE provides an easy way to expose C++ functions to Lua scripts using <code>CScriptableBase</code> class.</p> <p>See Integrations Between Lua and C++ in CRYENGINE docs. See ScriptBind_Chairloader.</p>"},{"location":"modding/xml/1.3.0-migration-guide/","title":"Migration Guide for 1.3.0","text":""},{"location":"modding/xml/1.3.0-migration-guide/#migration-guide-for-130","title":"Migration Guide for 1.3.0","text":"<p>Chairloader 1.3.0 uses new XML Merging v3, which breaks compatibility with old mods. This article guides you how to upgrade your mod to XML Merging v3.</p>"},{"location":"modding/xml/1.3.0-migration-guide/#common-steps","title":"Common steps","text":"<ol> <li>Remove all <code>ch:patch_mode</code>.    This mode is now the default. If you need the old behavior without <code>ch:patch_mode=\"true\"</code> (replace the entire node), set <code>ch:action=\"replace\"</code>.</li> <li>Replace <code>ch:apply_if</code> with <code>ch:applyIf</code>.    Attribute was renamed for consistency.</li> <li>Replace <code>ch:remove=\"true\"</code> with <code>ch:action=\"delete\"</code>. <code>ch:patch_mode</code> and <code>ch:remove</code> were combined into <code>ch:action</code>.</li> </ol>"},{"location":"modding/xml/1.3.0-migration-guide/#level-steps","title":"Level steps","text":"<p>For each <code>mission_mission0.xml</code> file:</p> <ol> <li>Make sure that every node in <code>&lt;Objects&gt;</code> (like <code>&lt;Entity&gt;</code>, <code>&lt;Object&gt;</code>, <code>&lt;Decal&gt;</code>) has <code>EntityGuid</code> attribute. This attribute is generated for non-entities. See Chairloader's PreyFiles for reference.</li> <li>Remove all <code>EntityId</code> attributes from <code>&lt;Entity&gt;</code>. This ID is now auto-generated. Click here for details.</li> <li>Replace all references of EntityID (e.g. in flowgraphs and entity links) with <code>$(EntityId:[guid])</code>. Click here for details.</li> </ol> <p>For each level: 1. Delete <code>serialize.xml</code> file. This file is now auto-generated. Set <code>ch:serialize=\"true\"</code> for entities that you want to serialize. Click here for details.</p>"},{"location":"modding/xml/1.3.0-migration-guide/#special-steps","title":"Special steps","text":"<p>Try to install and merge your mod. You might get a few more errors.</p> <ul> <li><code>Error: Set ch:action=\"replaceChildren\" to replace children but merge attributes</code>   This node's children can't be patched. You must set <code>ch:action=\"replaceChildren\"</code> so all of the node's children are replaced by your node's.</li> <li><code>Index attribute is missing for an array element</code>   The node is now an array. Array node must specify <code>ch:index</code> attribute so the merger knows which node you want to mod. Find the index in in the file in Chairloader's PreyFiles.</li> <li><code>Read-only attribute ? was changed from '?' to '?'</code>   Certain attributes (like internal names) are now read-only. Mods can't modify them on existing nodes. Revert the change in your mod or just remove the attribute.</li> </ul>"},{"location":"modding/xml/basic-xml-mod/","title":"Basic XML Mod","text":""},{"location":"modding/xml/basic-xml-mod/#basic-xml-mod","title":"Basic XML Mod","text":"<p>This article will guide you how to make a simple XML mod that changes the amount of health that Medkits restore. This guide implies that you use VS Code and shows you a way to search for things in game files.</p>"},{"location":"modding/xml/basic-xml-mod/#prerequisites","title":"Prerequisites","text":"<ol> <li>Create an empty mod</li> <li>Install Visual Studio Code as specified in the article linked above</li> </ol>"},{"location":"modding/xml/basic-xml-mod/#step-1-looking-for-what-to-change","title":"Step 1. Looking for what to change","text":"<ol> <li>Open <code>ChairManager/PreyFiles</code> in VS Code. This folder contains all XML files that you can mod.</li> <li>Press <code>Ctrl+Shift+F</code> to open Search All Files.</li> <li>Type <code>medkit</code>. This will show a large number of results.</li> <li>Press \"View as Tree\" and \"Collapse All\" buttons at the top to make it easier to navigate.</li> <li>Entities (e.g. interactive objects) are defined in <code>Libs/EntityArchetypes</code>. Open the first search result in <code>Libs/EntityArchetypes/ArkPickups.xml</code>.    <pre><code> &lt;EntityPrototype\n     Name=\"Medical.MedKit\"\n     Id=\"{58D44466-33E6-491B-B0F1-9FE4B0FAE192}\"\n     Library=\"ArkPickups\"\n     Class=\"ArkMedKit\"\n     Description=\"\"\n     ArchetypeId=\"10739735956144611826\"&gt;\n     &lt;Properties\n         metaTags_ArkMetaTags=\"3149325216955299302\"\n         bAvailableForRandom=\"1\"\n    ...\n</code></pre></li> <li>The game uses signals to apply effects like damage or healing. Navigate to <code>AppliedOnConsume</code> element.    <pre><code>         &lt;AppliedOnConsume\n             es_RestoredPoints=\"HEALTH\"\n             signalpackage_SignalPackage=\"7745561655334079461\"&gt;\n             &lt;OptionalAbilityRequirement\n                 ability_AbilityRequirement=\"3149325216929346739\"\n                 signalpackage_AbilityRequirementSignalPackage=\"10641886185836882035\" /&gt;\n         &lt;/AppliedOnConsume&gt;\n</code></pre></li> <li>This element states that when a medkit is comsumed, signal package with ID <code>7745561655334079461</code> is sent to the player.    Signal package is a combination of signals and their values sent at once.</li> <li>Press <code>Ctrl+Shift+F</code> and search for <code>7745561655334079461</code>.</li> <li>Open the result in <code>Ark/SignalSystem/Packages.xml</code>.    <pre><code> &lt;package\n     name=\"MedKit\"\n     id=\"7745561655334079461\"&gt;\n     &lt;signal\n         signalID=\"7745561656291547932\"\n         value=\"300\" /&gt;\n</code></pre></li> <li>It states that this package will create a signal with ID <code>7745561656291547932</code> and value <code>300</code> (30 health points).</li> <li>You can search all files for <code>7745561656291547932</code>. Open the result in <code>Ark/SignalSystem/Signals.xml</code> to find out what that signal actually is.</li> <li>You will need to change the value <code>300</code> to a different one.</li> </ol>"},{"location":"modding/xml/basic-xml-mod/#step-2-modifying-the-file","title":"Step 2. Modifying the file","text":"<ol> <li>Open your mod folder in VS Code. Create a folder named <code>Data</code>. </li> <li>Create the folders <code>Ark/SignalSystem</code> and create an empty file named <code>Packages.xml</code> </li> <li>Copy and paste the root objects from the original file. Don't forget to close the <code>&lt;packages&gt;</code> tag. </li> <li>Copy and paste the element for package with ID <code>7745561655334079461</code> </li> <li>Change the value to something else. In this case, <code>10</code> (1 hp). </li> <li>Save the file by pressing <code>Ctrl+S</code></li> </ol>"},{"location":"modding/xml/basic-xml-mod/#step-3-applying-and-testing","title":"Step 3. Applying and testing","text":"<ol> <li>Apply the changes in the game:<ul> <li>Preditor: Restart Predtior. It will merge the files automatically.</li> <li>Game: Press \"Merge Mods\" in ChairManager</li> </ul> </li> <li>Try it out. Launch Preditor/Game</li> <li>In Debug Menu at the top, press <code>Campaign -&gt; Clean Load Level -&gt; Lobby</code></li> <li>Jump down to take damage</li> <li>Spawn a medkit: <code>Debug Menu -&gt; Items -&gt;Give Item: -&gt; MedKit</code></li> <li>Use the medkit and check how much health was restored</li> <li>Alternatively, check the description of the Medkit item</li> </ol>"},{"location":"modding/xml/basic-xml-mod/#conclusion","title":"Conclusion","text":"<p>You now have a basic understanding of how XML mods work, how to look for things to change and how to make an XML mod.</p>"},{"location":"modding/xml/legacy-mod-conversion/","title":"Legacy Mod Conversion","text":""},{"location":"modding/xml/legacy-mod-conversion/#legacy-mod-conversion","title":"Legacy Mod Conversion","text":"<p>Chairloader has a command line tool to convert a legacy .pak mod into a Chairloader mod. This tool removes the need to manually find changes in the mod.</p>"},{"location":"modding/xml/legacy-mod-conversion/#usage","title":"Usage","text":"<ol> <li>Create two folders:</li> <li><code>legacy</code> - for original mod files</li> <li><code>chair</code> - for converted files</li> <li>Unpack .pak into <code>legacy</code> folder.</li> <li>If this was a <code>level.pak</code> file, you must move its contents to <code>legacy/Levels/Campaign/[xxxx]/[yyyy]/level</code>. Replace <code>[xxxx]/[yyyy]</code> with level path.</li> <li>Open Command Prompt in ChairManager folder.</li> <li>Type this command. Replace [path/to/legacy] and [path/to/chair] with paths to created folders.    <pre><code>.\\LegacyModConverter.exe --type-lib XmlTypeLibrary.xml --merging-lib MergingLibrary.xml --prey-files-dir PreyFiles --legacy-mod-dir [path/to/legacy] --out-dir [path/to/chair]\n</code></pre></li> <li>Check the log file and fix errors (if you have any)</li> </ol>"},{"location":"modding/xml/legacy-mod-conversion/#limitations","title":"Limitations","text":"<p>This tool doesn't have full support for array nodes. Array nodes are copied as-is with <code>ch:action=\"replaceChildren\"</code>.</p>"},{"location":"modding/xml/level-patching/","title":"Level Patching","text":""},{"location":"modding/xml/level-patching/#level-patching","title":"Level Patching","text":"<p>Chairloader has special handling for level objects in <code>mission_mission0.xml</code> file.</p>"},{"location":"modding/xml/level-patching/#automatic-guid-generation","title":"Automatic GUID Generation","text":"<p>There are two major types of level objects: entities and non-entities. Entities have <code>EntityGUID</code> attribute (random 64-bit ID in hex). Non-entities don't have that attribute.</p> <p>Chairloader automatically generates <code>EntityGUID</code> for non-entity objects and sets <code>ch:fakeGuid=\"true\"</code> attribute. After all mods are merged, auto-generated GUIDs are removed from the file.</p>"},{"location":"modding/xml/level-patching/#automatic-entityid-generation","title":"Automatic EntityID Generation","text":"<p>Each level entity must have a unique <code>EntityId</code> attribute, which is a sequential 16-bit integer. To prevent conflicts between mods, Chairloader mods are not allowed to specify <code>EntityId</code> at all. After all mods are merged, Chairloader automatically assigns Entity IDs to mod entities.</p> <p>Sometimes you need to know the Entity ID in the XML (e.g. to reference it from a flowgraph). Use values in the format <code>$(EntityId:[guid])</code> to reference an entity. This format only works in <code>mission_mission0.xml</code> and only references the entities in this file.</p> <pre><code>&lt;EntityLinks&gt;\n    &lt;Link\n        TargetId=\"$(EntityId:409E604DF4F0F65F)\"\n        Name=\"NewLink\" /&gt;\n&lt;/EntityLinks&gt;\n</code></pre>"},{"location":"modding/xml/level-patching/#automatic-serializexml-generation","title":"Automatic serialize.xml generation","text":"<p><code>serialize.xml</code> lists the entities that must be serialized (written in the game's save file). <code>serialize.xml</code> references them by <code>EntityId</code>. Since EntityIDs are assigned by Chairloader, mods can't modify this file. Instead, set <code>ch:serialize=\"true\"</code> attribute on entities that you wish to serialize. After all mods are merged, Chairloader will generate <code>serialize.xml</code> for each level based on <code>ch:serialize</code> values.</p>"},{"location":"modding/xml/meta-sequences/","title":"Meta Sequences","text":""},{"location":"modding/xml/meta-sequences/#meta-sequences","title":"Meta Sequences","text":"<p>Chairloader mods can include special attributes in XML files. They will be processed by Chairloader when merging.</p>"},{"location":"modding/xml/meta-sequences/#wildcards-expression-evaluation","title":"Wildcards (expression evaluation)","text":"<p>Modders can add arbitrary Lua expressions into XML attribute and element values. For example, they can reference values in the mod config, perform math calculations or string concatenation.</p> <p>Wildcards are expanded before everything else.</p> <p>Wildcards must be enclosed in <code>{{</code> and <code>}}</code> tags.</p> <p>Examples: </p><pre><code>&lt;Element something=\"{{ 2 + 2 }}\" /&gt;\n&lt;Element something=\"{{ valueFromConfig }}\" /&gt;\n</code></pre><p></p>"},{"location":"modding/xml/meta-sequences/#patchingreplacingdeletion-chaction","title":"Patching/Replacing/Deletion (ch:action)","text":"<p>You can add <code>ch:action</code> attribute to specify how XML node should be modded. This attribute replaces <code>ch:patch_mode</code> from previous versions of Chairloader.</p> <ul> <li><code>patch</code> (default)   Mod node will be merged into the original node. Specified attributes will be update, while non-specified attributes will stay the same. Child nodes are merged as well.</li> <li><code>delete</code>   If node is found in the original file, it will be deleted.</li> <li><code>replace</code>   Mod will completely replace the original node.</li> <li><code>replaceChildren</code>   Attributes are merged like in <code>patch</code>. Child nodes are replaced like in <code>replace</code></li> </ul>"},{"location":"modding/xml/meta-sequences/#conditionals-chapplyif","title":"Conditionals (ch:applyIf)","text":"<p>You can add <code>ch:applyIf</code> attribute to any XML element. If that attribute is set and contains a \"true\" value (e.g. <code>true</code>, <code>yes</code>, <code>1</code>) after wildcard expansion, the element will be merged. If the value is false, the element is ignored (as if it doesn't exist in the mod).</p> <p>Example (from Touch-Up): </p><pre><code>&lt;ArkHacking&gt;\n    &lt;DifficultyLevels ch:applyIf=\"{{ Hacking_TimeChanges }}\"&gt;\n        &lt;DifficultyLevel minTravelDistance=\"1.0\" maxTravelDistance=\"1.5\" timePerPuzzle=\"12.0\" chainLength=\"1\" pathObstacles=\"2\" pathStunObstacles=\"2\" otherStunObstacles=\"4\" /&gt;\n        &lt;DifficultyLevel minTravelDistance=\"1.0\" maxTravelDistance=\"1.5\" timePerPuzzle=\"20.0\" chainLength=\"1\" pathObstacles=\"2\" pathStunObstacles=\"2\" otherStunObstacles=\"4\" /&gt;\n        &lt;DifficultyLevel minTravelDistance=\"1.0\" maxTravelDistance=\"1.5\" timePerPuzzle=\"25.0\" chainLength=\"2\" pathObstacles=\"2\" pathStunObstacles=\"2\" otherStunObstacles=\"4\" /&gt;\n        &lt;DifficultyLevel minTravelDistance=\"1.0\" maxTravelDistance=\"1.5\" timePerPuzzle=\"30.0\" chainLength=\"2\" pathObstacles=\"2\" pathStunObstacles=\"2\" otherStunObstacles=\"4\" /&gt;\n    &lt;/DifficultyLevels&gt;\n&lt;/ArkHacking&gt;\n</code></pre><p></p>"},{"location":"modding/xml/meta-sequences/#based-on-chbasedon","title":"Based On (ch:basedOn)","text":"<p><code>ch:basedOn</code> allows your mod to create a copy of an existing element (with changes from all other mods) and patch in your custom changes. This attribute used to be called <code>ch:copy_sibling</code>.</p> <p>Value format: <code>\"queryAttribute1=value1,queryAttribute2=value2\"</code></p> <p>Example: </p><pre><code>&lt;EntityPrototype\n    Name=\"Mimics.Mimic.TopHat\"\n    Id=\"{A6574C2A-284F-4B39-812B-F777ECEAEEAB}\"\n    ArchetypeId=\"4932200438019026768\"\n    ch:basedOn=\"Name=Mimics.Mimic\"&gt;\n    &lt;Properties\n        fileModel=\"Objects/characters/Aliens/Mimic/TopHat/Mimic_top_hat.cdf\"/&gt;\n&lt;/EntityPrototype&gt;\n</code></pre><p></p>"},{"location":"preditor/architecture-overview/","title":"Architecture Overview","text":""},{"location":"preditor/architecture-overview/#architecture-overview","title":"Architecture Overview","text":"<p>This article will focus on how Preditor is structured and how it implements certain things.</p> <p>Preditor functions by patching and loading the game engine (<code>PreyDll.dll</code>).</p>"},{"location":"preditor/architecture-overview/#modules","title":"Modules","text":"<p>Preditor is split into quite a large number of modules. Each module is a static library that implements a set of interfaces. Interfaces themselves are declared in the Common module.</p> <p>Preditor uses a primitive form of inversion of control via static factory methods, which are implemented in the module:</p> <pre><code>// Common/Preditor/IExample.h\nstruct IExample\n{\n    //! @returns an instance of Example.\n    static std::unique_ptr&lt;IExample&gt; CreateInstance();\n\n    virtual ~IExample() {}\n    virtual void ExampleMethod() = 0;\n}\n\n// Example/Example.cpp\nstd::unique_ptr&lt;IExample&gt; IExample::CreateInstance()\n{\n    return std::make_unique&lt;Example&gt;();\n}\n</code></pre>"},{"location":"preditor/architecture-overview/#list-of-modules","title":"List of modules","text":"<ul> <li>Assets - Asset importing and merging (XML, textures, models, ...).</li> <li>Common - Code shared between all modules (mostly interfaces).</li> <li>EditTools - Editor tools (select, move, rotate, scale, ...).</li> <li>Engine - Patches for the engine.</li> <li>FGE - Flowgraph Editor.</li> <li>GameEditor - Scene Editor for runtime entity inspection and editing.</li> <li>Input - The Input System.</li> <li>Launcher - The executable that links all modules together and launches the game engine.</li> <li>LevelEditor - Scene Editor for level editing.</li> <li>Main - Main module with global managers and UI.</li> <li>Viewport - Game and Scene viewport windows.</li> </ul>"},{"location":"preditor/architecture-overview/#global-environment","title":"Global Environment","text":"<p>Each Preditor module has access to a global structure <code>SPreditorEnvironment* gPreditor</code> declared in <code>Common/Preditor/Environment.h</code>. This structure contains pointers to most interfaces. It is used in place of a proper dependency injection system.</p> <p>The contents of this structure may only be set in Main and Launcher modules.</p>"},{"location":"preditor/architecture-overview/#projects","title":"Projects","text":"<p>Preditor implements a project system. Each project is assumed to be an individual mod for Chairloader. Preditor will create a <code>.user</code> directory in the project for temporary files. It should not be distributed to other users or checked into version control. Each project is loaded separately from each other or from the normal game. That means that no save or config files are shared between Preditor and normal game.</p>"},{"location":"preditor/architecture-overview/#project-structure","title":"Project Structure","text":"<ul> <li>.user - Temporary Preditor files.<ul> <li>ImportedAssets - imported (converted) asset files.</li> <li>MergedAssets - assets after merging. This is analogous to <code>patch_chairloader.pak</code>.</li> <li>Mods - additional mods that can be enabled in Preditor <code>File -&gt; Mod Manager</code>.</li> <li>User - game's save directory.</li> </ul> </li> <li>Data - assets for merging (just like in a Chairloader mod).</li> <li>.gitignore - List of ignored file for Git. By default, ignores <code>.user</code> and CMake build directory.</li> <li>.preditor_project - main project file.</li> <li>ModInfo.xml - Mod Info for Chairloader.</li> </ul>"},{"location":"preditor/architecture-overview/#asset-system","title":"Asset System","text":""},{"location":"preditor/architecture-overview/#merging","title":"Merging","text":"<p>Preditor supports asset merging without game restart. This is implemented using \"MOD Paths\" in <code>ICryPak</code>, the game's file system library. Instead of creating a <code>.pak</code> file and putting it into <code>GameSDK/Precache</code>, the files are copied on the disk to <code>.user/MergedAssets/GameSDK</code>. The game will use them instead of any files in <code>.pak</code>s.</p>"},{"location":"preditor/architecture-overview/#import","title":"Import","text":"<p>Preditor additionally supports asset import. In this context, \"import\" means taking a source file (for example, a <code>.png</code> image) and converting it into a format that CryEngine understands (for example, a <code>.dds</code> texture).</p> <p>At the moment, no importers are implemented.</p>"},{"location":"preditor/architecture-overview/#metadata-files","title":"Metadata Files","text":"<p>Each mod asset may have a metadata file (for example, for <code>Example.xml</code> metadata file is <code>Example.xml.prey</code>). This is an XML file in the following format:</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;Metadata\n    skipMerge=\"0\"\n    mergeSourceFile=\"1\"\n    importerName=\"\"&gt;\n&lt;/Metadata&gt;\n</code></pre> <p>Metadata files specify how an asset should be imported and merged.</p>"},{"location":"preditor/architecture-overview/#scene-editors","title":"Scene Editors","text":"<p>Preditor uses an abstraction called \"Scene Editor\" to manipulate the game world. There are currently two scene editors: - Game Editor - runtime entity manipulation - Level Editor - level editing. Instead of entities, level objects are manipulated.</p> <p>Scene editors are instantiated by <code>SceneEditorManager</code> in the Main module when loading a level. Normal load will create GameEditor. To enter the LevelEditor mode, run the following console command:</p> <pre><code>map_edit path_to_the_map\n\n# Example:\nmap_edit campaign/research/lobby\n</code></pre>"},{"location":"preditor/architecture-overview/#edit-tools","title":"Edit Tools","text":"<p>Edit Tools are actual tools used by the end-user to manipulate game objects and entities. They are implemented in the EditTools module. Each scene editor exposes <code>IObjectManipulator</code> interface for the edit tools.</p>"},{"location":"preditor/architecture-overview/#engine-patches","title":"Engine Patches","text":"<p>To make Preditor possible, it needs apply a set of patches to the engine and then load it. This is handled by the Engine module.</p> <p>It implements the following things: - Console redirection to Visual Studio debugger - Viewport window rendering - Viewport window input - ImGui implementation using CryEngine's renderer and D3D11 - Loading the engine - Running the engine's update function with configurable flags     - Flags are for pausing the game - Patches for running the engine in minimal configuration     - No renderer, no window, no game logic     - Used when extracting PAK files</p>"},{"location":"preditor/architecture-overview/#flowgraph-editor","title":"Flowgraph Editor","text":"<p>Work In Progress</p>"},{"location":"preditor/architecture-overview/#input-system","title":"Input System","text":"<p>Preditor implements its own input system instead of using CryEngine's (reason: CryEngine input doesn't work when paused).</p>"},{"location":"preditor/architecture-overview/#actions-and-action-sets","title":"Actions and Action Sets","text":"<p>Each command (e.g. pause/unpause, switch to different edit tool) is represented by an action (<code>IKeyAction</code>). An action may have a number of key bindings that may trigger it.</p> <p>An action may be a modifier (e.g. Shift to speed up the camera). In this case, it may be bound to left or right modifier key.</p> <p>Actions are grouped into sets (<code>IKeyActionSet</code>). Individual sets may be toggled on or off (e.g. <code>viewport_camera</code> action set is only enabled when actively controlling the scene camera). Each set has a priority. If the same key is bound to multiple actions from different sets, in will only trigger the set with highest priority.</p> <p>Actions and Action Sets are defined in <code>ChairManager/Data/Preditor/ActionSets.xml</code>.</p>"},{"location":"preditor/architecture-overview/#key-bindings","title":"Key Bindings","text":"<p>Any key can be bound to any action. Key bindings may also contain modifier keys (Ctrl, Alt, Shift). All key names can be found in <code>ChairManager/Data/Preditor/KeyMap.xml</code>.</p> <p>The input system doesn't distinguish left and right modifier keys. Available modifiers: - <code>crtl</code> - <code>alt</code> - <code>shift</code></p> <p>Example key bindings: \"<code>w</code>\", \"<code>f4</code>\", \"<code>lshift</code>\", \"<code>ctrl+f5</code>\", \"<code>ctrl+alt+shift+b</code>\".</p>"},{"location":"preditor/architecture-overview/#viewport-window","title":"Viewport Window","text":"<p>In Preditor game window content is redirected into a separate viewport window.</p> <p>The viewport window has two modes (use <code>F4</code> to switch between them): - Game Viewport - Scene Viewport</p>"},{"location":"preditor/architecture-overview/#game-viewport","title":"Game Viewport","text":"<p>In this mode the viewport window contains the game output. It is implemented by hooking the engine's swap-chain (<code>IDXGISwapChain</code>) and redirecting it into a render-texture. That texture is then rendered in an ImGui window.</p>"},{"location":"preditor/architecture-overview/#scene-viewport","title":"Scene Viewport","text":"<p>This mode functions as a free-cam mode. You can look around with the mouse and move the camera by right-clicking the viewport and pressing WASDQE+Shift. You can select objects by left-clicking. Shift+left-click will add the clicked object to current selection.</p> <p>In Game Editor mode, you have the option between \"Mesh\" and \"Physics\" selection modes. \"Mesh\" mode lets you select any object by clicking on its 3D-model (\"mesh\"). It is currently limited to non-animated (\"static\") objects. \"Physics\" mode uses a physics raycast (RWI - ray-world intersection) and lets you select any object with a physics collider.</p>"},{"location":"using-chairloader/","title":"Basic Use","text":""},{"location":"using-chairloader/#basic-use","title":"Basic Use","text":""},{"location":"using-chairloader/command-line-options/","title":"Command Line Options","text":""},{"location":"using-chairloader/command-line-options/#command-line-options","title":"Command Line Options","text":"<p>This page lists all known command line options for Chairloader and Prey.</p>"},{"location":"using-chairloader/command-line-options/#chairloader","title":"Chairloader","text":"<p>These options can be added to <code>Prey.exe</code> command line. In Steam, they can be set in Properties -&gt; Launch Options.</p> <code>-nochair</code> <p>LDisable Chairloader and Mod DLLs.</p> <code>-nopatches</code> <p>LDisable optional patches for troubleshooting.</p> <code>-chair_mods_path \\&lt;path to a directory&gt;</code> <p>LOverrides the path to Mods directory.</p> <code>-nodevmode</code> <p>LForcefully disables engine's developer mode, even in Debug builds. Overrides <code>-devmode</code>.</p> <code>-devmode</code> <p>LEnables the engine's developer mode. Automatically set in Debug builds. Enables asserts in Release builds.</p> <code>-trainer</code> <p>LEnables trainer functionality. Requires <code>-devmode</code>.</p> <code>-editor</code> <p>LEnables the In-Game Editor for mod development.</p> <code>-noaudio</code> <p>LDisables the engine's audio subsystem. Breaks all dialog triggers and hard-locks story progression. Reduces start up time by 10 seconds.</p> <code>-renderdoc</code> <p>LThe engine will wait for 10 seconds until RenderDoc is injected.</p> <code>-shadersdebug &lt;int&gt;</code> <p>L(When shader compiler is enabled) Sets the value of <code>r_shadersdebug</code>.</p> <code>-shaderthreads &lt;int&gt;</code> <p>L(When shader compiler is enabled) Sets the number of threads to use to compile shaders.</p> <code>-lua_storedebug &lt;int&gt;</code> <p>LEnables (1) or disables (0) Lua debug output. Disabled by default in normal mode, enabled in dev mode.</p>"},{"location":"using-chairloader/command-line-options/#engine","title":"Engine","text":"<p>These can be used in the same way as Chairloader's options. Some of these were found in CRYENGINE 5 source code and were not tested with Prey.</p> <p><code>+command_name command_arg</code></p> <p>Not Tested</p> Executes the console command when the game is started. <code>-epicuserid &lt;string&gt;</code> <p>Set by Epic Games Store launcher. Influences the save game path.</p> <p><code>-nomouse</code></p> <p>Not Tested</p> Disables mouse input, only leaving keyboard and gamepads. <p><code>-autodetect</code></p> <p>Not Tested</p> Forces the game to auto-adjust graphics settings to match the hardware. <p><code>-norandom</code></p> <p>Not Tested</p> Seeds all PRNGs with constant seed of 0."},{"location":"using-chairloader/command-line-options/#preditor","title":"Preditor","text":"<p>In addition to the options listed below, it accepts everything the engine and Chairloader support after. Engine options need to be set after <code>--</code>.</p> <code>--</code> <p>Mark the end of Preditor options. The following will be passed to the engine.</p> <code>--extract</code> <p>Enable Extraction Mode. It will load the engine and extract paks set in ExtractList.xml.</p> <code>--game-path &lt;full path&gt;</code> <p>Path to the root game directory (where GameSDK is).</p> <code>--output-path &lt;full path&gt;</code> <p>Path to the output directory.</p>"},{"location":"using-chairloader/editor/","title":"Chairloader Editor","text":""},{"location":"using-chairloader/editor/#chairloader-editor","title":"Chairloader Editor","text":"<p>The editor is designed to mimic the cryengine game editor, and implements a small subset of those features</p> <p>To launch check <code>Editor</code> in the Chair Manager launch options menu. This is a work in progress interface, so stability may suffer while using the editor.</p>"},{"location":"using-chairloader/editor/#free-cam","title":"Free Cam","text":"<ul> <li>Improved free cam with configurable speed and an intuitive interface</li> </ul>"},{"location":"using-chairloader/editor/#entity-selection","title":"Entity Selection","text":"<ul> <li>Click on any entity to select it while in free cam mode</li> <li>Displays the bounding box of the selected entity</li> </ul>"},{"location":"using-chairloader/editor/#hot-dll-reloading","title":"Hot DLL Reloading","text":"<ul> <li>Reload your mod DLL's while the game is running</li> <li>Reloads the level and all entities, so you can see your changes immediately</li> <li>This is a very powerful tool for rapid development</li> </ul>"},{"location":"using-chairloader/editor/#entity-manipulation","title":"Entity Manipulation","text":"<ul> <li>Edit position, rotation and scale of the selected entity</li> <li>Edit the entity's properties</li> <li>View script variables of the selected entity</li> <li>View physics variables of the selected entity</li> </ul>"},{"location":"using-chairloader/editor/#game-pause","title":"Game Pause","text":"<ul> <li>Pause the game while in free cam mode, which freezes all physics and animations</li> <li>This allows you to edit entities while the game is running, and then unpause the game to see the changes</li> </ul>"},{"location":"using-chairloader/trainers/","title":"Chairloader Tools","text":""},{"location":"using-chairloader/trainers/#chairloader-tools","title":"Chairloader Tools","text":"<p>These are internal modules that provide an array of useful functions in game. They possess many trainer-like features, including entity, player, and world manipulation. They are a statically linked library that is compiled into the main chairloader DLL.</p>"},{"location":"using-chairloader/trainers/#entity-manager","title":"Entity Manager","text":"<p>There are two primary functions in this module: the entity spawner and the entity list.</p> <p>The entity spawner is used to spawn entities. It can spawn any archetype that is loaded into the game, and can specify a position, faction, quantity, etc..</p> <p></p> <p>The entity list is a list of all entities in the game. It can be used to select entities and change their position, faction, and orientation. Additionally, for NPC's there are more options available.</p> <p></p>"},{"location":"using-chairloader/trainers/#player-manager","title":"Player Manager","text":""},{"location":"using-chairloader/trainers/#position-setting-and-saveload","title":"Position Setting and save/load","text":""},{"location":"using-chairloader/trainers/#health-armor-psi-stamina-and-status-manipulation","title":"Health, armor, psi, stamina, and status manipulation","text":""},{"location":"using-chairloader/trainers/#menu-for-granting-any-neuromod-in-the-game","title":"Menu for granting any neuromod in the game","text":""},{"location":"using-chairloader/trainers/#inventory-manipulation","title":"Inventory manipulation","text":""},{"location":"using-chairloader/trainers/#world-manager","title":"World Manager","text":"<ul> <li>Can load any level from any position in the game</li> <li>Can unlock keycards, passcodes, and passwords</li> <li>Can view the entire character list and view dev notes. Can also set characters as discovered through the menu.</li> <li>more coming soon!</li> </ul>"}]}